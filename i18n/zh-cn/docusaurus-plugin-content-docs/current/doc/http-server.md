---
title: HTTP Server
sidebar_label: HTTP Server 
hide_title: false
hide_table_of_contents: false
---

# HTTP Server

SRS内嵌了一个web服务器，支持api和简单的文件分发。

部署和使用SRS的内嵌http服务器，参考：[Usage: HTTP](./sample-http.md)

SRS的内置HTTP服务器已经参考GO的HTTP模块重写，满足商用要求，可以当作web服务器使用。参考：[#277](https://github.com/ossrs/srs/issues/277)

> Note: SRS只支持源站HTTP分发，边缘还是需要用Web服务器比如NGINX、SQUID或ATS等。

SRS也可以很好地与HTTP反向代理服务器一起使用，例如[NGINX](#nginx-proxy)和[Caddy](#caddy-proxy)。

## Use Scenario

它的定位很简单：智能手机上的摄像头。

Nginx/Apache/lighthttpd等众多HTTP server大佬就是专业的单反，老长老长镜头了。
难道有了单反智能手机上就不能有摄像头？不会吧！而且必须有。所以不是要和nginx拼个你死我活，
定位不一样，就像fms内嵌apache一样（不过fms嵌得很烂），真的有必要而且方便。

为何srs不内嵌一个nginx呢？智能手机上能内嵌一个单反长镜头么？我去，那是怪物吧。
nginx14万行代码，巨大无比，srs才2万行，如何能内嵌呢？最核心的原因是：srs需要提供http的api，
方便外部管理和调用；这点往往都毫无异议，但是提到srs要内嵌web服务器，就都炸开锅啦。
OK，其实就是http的api稍微扩展点，支持读文件后发送给客户端。

srs会一如既往的保持最简单，http的代码不会有多少行，功能不会有几个，就支持简单的文件分发就足够了。可以：
* 只需要部署一个服务器就可以分发RTMP和HLS。
* SRS对于HLS/HDS/DASH的支持会更完善。
* SRS可以支持点播，动态转封装等。
* SRS依然可以用nginx作为反向代理，或者禁用这个选项，使用nginx分发。

实际上，RTMP协议本身比HTTP复杂很多，所以st来做http分发，没有任何不可以的地方，更何况只是做部分。所以，淡定～

## Config

需要配置全局的HTTP端口和根目录的路径。

```bash
# embeded http server in srs.
# the http streaming config, for HLS/HDS/DASH/HTTPProgressive
# global config for http streaming, user must config the http section for each vhost.
# the embed http server used to substitute nginx in ./objs/nginx,
# for example, srs runing in arm, can provides RTMP and HTTP service, only with srs installed.
# user can access the http server pages, generally:
#       curl http://192.168.1.170:80/srs.html
# which will show srs version and welcome to srs.
# @remeark, the http embeded stream need to config the vhost, for instance, the __defaultVhost__
# need to open the feature http of vhost.
http_server {
    # whether http streaming service is enabled.
    # Overwrite by env SRS_HTTP_SERVER_ENABLED
    # default: off
    enabled on;
    # the http streaming listen entry is <[ip:]port>
    # for example, 192.168.1.100:8080
    # where the ip is optional, default to 0.0.0.0, that is 8080 equals to 0.0.0.0:8080
    # @remark, if use lower port, for instance 80, user must start srs by root.
    # Overwrite by env SRS_HTTP_SERVER_LISTEN
    # default: 8080
    listen 8080;
    # the default dir for http root.
    # Overwrite by env SRS_HTTP_SERVER_DIR
    # default: ./objs/nginx/html
    dir ./objs/nginx/html;
    # whether enable crossdomain request.
    # for both http static and stream server and apply on all vhosts.
    # Overwrite by env SRS_HTTP_SERVER_CROSSDOMAIN
    # default: on
    crossdomain on;
    # For https_server or HTTPS Streaming.
    https {
        # Whether enable HTTPS Streaming.
        # Overwrite by env SRS_HTTP_SERVER_HTTPS_ENABLED
        # default: off
        enabled on;
        # The listen endpoint for HTTPS Streaming.
        # Overwrite by env SRS_HTTP_SERVER_HTTPS_LISTEN
        # default: 8088
        listen 8088;
        # The SSL private key file, generated by:
        #       openssl genrsa -out server.key 2048
        # Overwrite by env SRS_HTTP_SERVER_HTTPS_KEY
        # default: ./conf/server.key
        key ./conf/server.key;
        # The SSL public cert file, generated by:
        #       openssl req -new -x509 -key server.key -out server.crt -days 3650 -subj "/C=CN/ST=Beijing/L=Beijing/O=Me/OU=Me/CN=ossrs.net"
        # Overwrite by env SRS_HTTP_SERVER_HTTPS_CERT
        # default: ./conf/server.crt
        cert ./conf/server.crt;
    }
}
```

## HTTP Vhost

同时，vhost上可以指定http配置（虚拟目录和vhost）：

```bash
vhost your_vhost {
    # http static vhost specified config
    http_static {
        # whether enabled the http static service for vhost.
        # default: off
        enabled     on;
        # the url to mount to, 
        # typical mount to [vhost]/
        # the variables:
        #       [vhost] current vhost for http server.
        # @remark the [vhost] is optional, used to mount at specified vhost.
        # @remark the http of __defaultVhost__ will override the http_stream section.
        # for example:
        #       mount to [vhost]/
        #           access by http://ossrs.net:8080/xxx.html
        #       mount to [vhost]/hls
        #           access by http://ossrs.net:8080/hls/xxx.html
        #       mount to /
        #           access by http://ossrs.net:8080/xxx.html
        #           or by http://192.168.1.173:8080/xxx.html
        #       mount to /hls
        #           access by http://ossrs.net:8080/hls/xxx.html
        #           or by http://192.168.1.173:8080/hls/xxx.html
        # default: [vhost]/
        mount       [vhost]/hls;
        # main dir of vhost,
        # to delivery HTTP stream of this vhost.
        # default: ./objs/nginx/html
        dir         ./objs/nginx/html/hls;
    }
}
```

注意：SRS1中的`http_stream`在SRS2改名为`http_server`，全局的server配置，即静态HTTP服务器，可用来分发dvr的HLS/FLV/HDS/MPEG-DASH等。

注意：SRS1中vhost的`http`在SRS2改名为`http_static`，和全局的`http_server`类似用来分发静态的文件。而SRS2新增的功能`http_remux`，用来动态转封装，将RTMP流转封装为 HTTP Live FLV/Mp3/Aac/Hls/Hds/MPEG-DASH流。

## HTTPS Server

SRS支持HTTPS，在配置中开启即可，默认使用子签名证书，若需要使用CA颁发的证书，请替换相关的文件。相关配置如下：

```bash
http_server {
    https {
        # Whether enable HTTPS Streaming.
        # Overwrite by env SRS_HTTP_SERVER_HTTPS_ENABLED
        # default: off
        enabled on;
        # The listen endpoint for HTTPS Streaming.
        # Overwrite by env SRS_HTTP_SERVER_HTTPS_LISTEN
        # default: 8088
        listen 8088;
        # The SSL private key file, generated by:
        #       openssl genrsa -out server.key 2048
        # Overwrite by env SRS_HTTP_SERVER_HTTPS_KEY
        # default: ./conf/server.key
        key ./conf/server.key;
        # The SSL public cert file, generated by:
        #       openssl req -new -x509 -key server.key -out server.crt -days 3650 -subj "/C=CN/ST=Beijing/L=Beijing/O=Me/OU=Me/CN=ossrs.net"
        # Overwrite by env SRS_HTTP_SERVER_HTTPS_CERT
        # default: ./conf/server.crt
        cert ./conf/server.crt;
    }
}
```

## Crossdomain

SRS默认开启了CORS跨域的支持，相关配置如下：

```bash
http_server {
    # whether enable crossdomain request.
    # for both http static and stream server and apply on all vhosts.
    # Overwrite by env SRS_HTTP_SERVER_CROSSDOMAIN
    # default: on
    crossdomain on;
}
```

## MIME

支持少量的MIME，见下表。

| 文件扩展名 | Content-Type |
| ------------- | -----------  |
| .ts | Content-Type: video/MP2T;charset=utf-8 |
| .m3u8 | Content-Type: application/x-mpegURL;charset=utf-8 |
| .json | Content-Type: application/json;charset=utf-8 |
| .css | Content-Type: text/css;charset=utf-8 |
| .swf | Content-Type: application/x-shockwave-flash;charset=utf-8 |
| .js | Content-Type: text/javascript;charset=utf-8 |
| .xml | Content-Type: text/xml;charset=utf-8 |
| 其他 | Content-Type: text/html;charset=utf-8 |

## Method

支持的Method包括：
* GET: 下载文件。

## Paths

HTTP/HTTPS API:

* `/api/` SRS HTTP API
* `/rtc/` SRS WebRTC API

HTTP/HTTPS Stream:

* `/{app}/{stream}` HTTP Stream mounted by publisher.

以下是一些与SRS一起使用的反向代理。

> Note: 通常，代理可以基于路径将API和Stream一起路由。

## Nginx Proxy

以下是作为文件[nginx.conf](https://github.com/ossrs/srs/blob/develop/trunk/conf/nginx.proxy.conf)的NGINX配置：

```
worker_processes  1;
events {
    worker_connections  1024;
}

http {
    include             /etc/nginx/mime.types;

    server {
        listen       80;
        listen       443 ssl http2;
        server_name  _;
        ssl_certificate      /usr/local/srs/conf/server.crt;
        ssl_certificate_key  /usr/local/srs/conf/server.key;

        # For SRS homepage, console and players
        #   http://r.ossrs.net/console/
        #   http://r.ossrs.net/players/
        location ~ ^/(console|players)/ {
           proxy_pass http://127.0.0.1:8080/$request_uri;
        }
        # For SRS streaming, for example:
        #   http://r.ossrs.net/live/livestream.flv
        #   http://r.ossrs.net/live/livestream.m3u8
        location ~ ^/.+/.*\.(flv|m3u8|ts|aac|mp3)$ {
           proxy_pass http://127.0.0.1:8080$request_uri;
        }
        # For SRS backend API for console.
        # For SRS WebRTC publish/play API.
        location ~ ^/(api|rtc)/ {
           proxy_pass http://127.0.0.1:1985$request_uri;
        }
    }
}
```

## Caddy Proxy

使用自动HTTPS的[CaddyServer](https://caddyserver.com/docs/getting-started)配置，请使用配置文件`Caddyfile`。

对于HTTP服务器，请注意设置默认端口：

```
:80
reverse_proxy /* 127.0.0.1:8080
reverse_proxy /api/* 127.0.0.1:1985
reverse_proxy /rtc/* 127.0.0.1:1985
```

对于HTTPS服务器，请启用一个域名：

```
example.com {
  reverse_proxy /* 127.0.0.1:8080
  reverse_proxy /api/* 127.0.0.1:1985
  reverse_proxy /rtc/* 127.0.0.1:1985
}
```

启动CaddyServer:

```
caddy start -config Caddyfile
```

## Nodejs KOA Proxy

nodejs koa 代理也非常适用于 SRS，请使用基于[node-http-proxy](https://github.com/nodejitsu/node-http-proxy)的[koa-proxies](https://www.npmjs.com/package/koa-proxies)，这里有一个示例：

```js
const Koa = require('koa');
const proxy = require('koa-proxies');
const BodyParser = require('koa-bodyparser');
const Router = require('koa-router');

const app = new Koa();
app.use(proxy('/api/', {target: 'http://127.0.0.1:1985/'}));
app.use(proxy('/rtc/', {target: 'http://127.0.0.1:1985/'}));
app.use(proxy('/*/*.(flv|m3u8|ts|aac|mp3)', {target: 'http://127.0.0.1:8080/'}));
app.use(proxy('/console/', {target: 'http://127.0.0.1:8080/'}));
app.use(proxy('/players/', {target: 'http://127.0.0.1:8080/'}));

// Start body-parser after proxies, see https://github.com/vagusX/koa-proxies/issues/55
app.use(BodyParser());

// APIs that depends on body-parser
const router = new Router();
router.all('/', async (ctx) => {
  ctx.body = 'Hello World';
});
app.use(router.routes());

app.listen(3000, () => {
  console.log(`Server start on http://localhost:3000`);
});
```

将其保存为 `index.js`，然后运行：

```
npm init -y 
npm install koa koa-proxies koa-proxies koa-bodyparser koa-router
node .
```

## HTTPX Proxy

好吧，[httpx-static](https://github.com/ossrs/go-oryx/tree/develop/httpx-static#usage) 是用 Go 编写的一个简单的 HTTP/HTTPS 代理：

```
go get github.com/ossrs/go-oryx/httpx-static
cd $GOPATH/bin
./httpx-static -http=80 -https=443 \
  -skey /usr/local/srs/etc/server.key -scert /usr/local/srs/etc/server.crt \
  -proxy=http://127.0.0.1:1985/api/v1/ \
  -proxy=http://127.0.0.1:1985/rtc/v1/ \
  -proxy=http://127.0.0.1:8080/
```

> Please make sure the path `/` is the last one.

Winlin 2015.1

![](https://ossrs.net/gif/v1/sls.gif?site=ossrs.net&path=/lts/doc/zh/v7/http-server)


